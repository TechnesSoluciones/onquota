name: AWS ECS Deployment

on:
  push:
    branches: [main, staging, develop]
    paths:
      - 'backend/**'
      - 'frontend/**'
      - '.github/workflows/aws-deploy.yml'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        type: choice
        options:
          - dev
          - staging
          - production

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

env:
  AWS_REGION: us-east-1
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com

jobs:
  # Determine environment based on branch
  setup:
    name: Setup Deployment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      deploy: ${{ steps.set-env.outputs.deploy }}

    steps:
      - name: Determine environment
        id: set-env
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
            echo "deploy=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" == "refs/heads/main" ]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "deploy=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" == "refs/heads/staging" ]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "deploy=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" == "refs/heads/develop" ]; then
            echo "environment=dev" >> $GITHUB_OUTPUT
            echo "deploy=true" >> $GITHUB_OUTPUT
          else
            echo "environment=dev" >> $GITHUB_OUTPUT
            echo "deploy=false" >> $GITHUB_OUTPUT
          fi

      - name: Display deployment info
        run: |
          echo "Environment: ${{ steps.set-env.outputs.environment }}"
          echo "Deploy: ${{ steps.set-env.outputs.deploy }}"

  # Build and push Backend Docker image
  build-backend:
    name: Build Backend
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.deploy == 'true'
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.ECR_REGISTRY }}/onquota-${{ needs.setup.outputs.environment }}-backend
          tags: |
            type=sha,prefix={{branch}}-
            type=ref,event=branch
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value=${{ github.sha }}

      - name: Build and push Backend image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile.aws
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

      - name: Scan image for vulnerabilities
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.ECR_REGISTRY }}/onquota-${{ needs.setup.outputs.environment }}-backend:${{ github.sha }}
          format: 'sarif'
          output: 'trivy-backend-results.sarif'
          severity: 'CRITICAL,HIGH'
        continue-on-error: true

      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: 'trivy-backend-results.sarif'
          category: trivy-backend
        continue-on-error: true

  # Build and push Frontend Docker image
  build-frontend:
    name: Build Frontend
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.deploy == 'true'
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.ECR_REGISTRY }}/onquota-${{ needs.setup.outputs.environment }}-frontend
          tags: |
            type=sha,prefix={{branch}}-
            type=ref,event=branch
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value=${{ github.sha }}

      - name: Build and push Frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile.aws
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64
          build-args: |
            NEXT_PUBLIC_API_URL=${{ secrets.NEXT_PUBLIC_API_URL }}
            NEXT_PUBLIC_APP_NAME=OnQuota

      - name: Scan image for vulnerabilities
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.ECR_REGISTRY }}/onquota-${{ needs.setup.outputs.environment }}-frontend:${{ github.sha }}
          format: 'sarif'
          output: 'trivy-frontend-results.sarif'
          severity: 'CRITICAL,HIGH'
        continue-on-error: true

      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: 'trivy-frontend-results.sarif'
          category: trivy-frontend
        continue-on-error: true

  # Run database migrations
  migrate-database:
    name: Database Migrations
    runs-on: ubuntu-latest
    needs: [setup, build-backend]
    if: needs.setup.outputs.deploy == 'true'
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Run database migrations
        run: |
          # Get ECS cluster and task definition
          CLUSTER_NAME="onquota-${{ needs.setup.outputs.environment }}-cluster"
          TASK_DEF="onquota-${{ needs.setup.outputs.environment }}-backend"

          # Get VPC configuration
          SUBNETS=$(aws ec2 describe-subnets \
            --filters "Name=tag:Name,Values=onquota-${{ needs.setup.outputs.environment }}-vpc/Private*" \
            --query 'Subnets[*].SubnetId' \
            --output text | tr '\t' ',')

          SECURITY_GROUP=$(aws ec2 describe-security-groups \
            --filters "Name=tag:Name,Values=onquota-${{ needs.setup.outputs.environment }}-ecs-sg" \
            --query 'SecurityGroups[0].GroupId' \
            --output text)

          # Run migration task
          aws ecs run-task \
            --cluster $CLUSTER_NAME \
            --task-definition $TASK_DEF \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[$SUBNETS],securityGroups=[$SECURITY_GROUP],assignPublicIp=DISABLED}" \
            --overrides '{"containerOverrides":[{"name":"backend","command":["alembic","upgrade","head"]}]}' \
            --region ${{ env.AWS_REGION }}

          echo "Database migration task started"

  # Deploy Backend to ECS
  deploy-backend:
    name: Deploy Backend
    runs-on: ubuntu-latest
    needs: [setup, build-backend, migrate-database]
    if: needs.setup.outputs.deploy == 'true'
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update ECS service
        run: |
          SERVICE_NAME="onquota-${{ needs.setup.outputs.environment }}-backend"
          CLUSTER_NAME="onquota-${{ needs.setup.outputs.environment }}-cluster"

          aws ecs update-service \
            --cluster $CLUSTER_NAME \
            --service $SERVICE_NAME \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}

          echo "Backend deployment initiated"

      - name: Wait for service stability
        run: |
          SERVICE_NAME="onquota-${{ needs.setup.outputs.environment }}-backend"
          CLUSTER_NAME="onquota-${{ needs.setup.outputs.environment }}-cluster"

          aws ecs wait services-stable \
            --cluster $CLUSTER_NAME \
            --services $SERVICE_NAME \
            --region ${{ env.AWS_REGION }}

          echo "Backend deployment completed successfully"

  # Deploy Frontend to ECS
  deploy-frontend:
    name: Deploy Frontend
    runs-on: ubuntu-latest
    needs: [setup, build-frontend, deploy-backend]
    if: needs.setup.outputs.deploy == 'true'
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update ECS service
        run: |
          SERVICE_NAME="onquota-${{ needs.setup.outputs.environment }}-frontend"
          CLUSTER_NAME="onquota-${{ needs.setup.outputs.environment }}-cluster"

          aws ecs update-service \
            --cluster $CLUSTER_NAME \
            --service $SERVICE_NAME \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}

          echo "Frontend deployment initiated"

      - name: Wait for service stability
        run: |
          SERVICE_NAME="onquota-${{ needs.setup.outputs.environment }}-frontend"
          CLUSTER_NAME="onquota-${{ needs.setup.outputs.environment }}-cluster"

          aws ecs wait services-stable \
            --cluster $CLUSTER_NAME \
            --services $SERVICE_NAME \
            --region ${{ env.AWS_REGION }}

          echo "Frontend deployment completed successfully"

  # Deploy Celery Workers
  deploy-celery:
    name: Deploy Celery Workers
    runs-on: ubuntu-latest
    needs: [setup, build-backend, deploy-backend]
    if: needs.setup.outputs.deploy == 'true'
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update Celery Worker service
        run: |
          aws ecs update-service \
            --cluster onquota-${{ needs.setup.outputs.environment }}-cluster \
            --service onquota-${{ needs.setup.outputs.environment }}-celery-worker \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}

      - name: Update Celery Beat service
        run: |
          aws ecs update-service \
            --cluster onquota-${{ needs.setup.outputs.environment }}-cluster \
            --service onquota-${{ needs.setup.outputs.environment }}-celery-beat \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}

      - name: Update Flower service
        run: |
          aws ecs update-service \
            --cluster onquota-${{ needs.setup.outputs.environment }}-cluster \
            --service onquota-${{ needs.setup.outputs.environment }}-flower \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}

  # Post-deployment verification
  verify-deployment:
    name: Verify Deployment
    runs-on: ubuntu-latest
    needs: [setup, deploy-backend, deploy-frontend]
    if: needs.setup.outputs.deploy == 'true'
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get ALB DNS
        id: alb
        run: |
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --names onquota-${{ needs.setup.outputs.environment }}-alb \
            --query 'LoadBalancers[0].DNSName' \
            --output text \
            --region ${{ env.AWS_REGION }})

          echo "alb_dns=$ALB_DNS" >> $GITHUB_OUTPUT
          echo "ALB DNS: $ALB_DNS"

      - name: Health check - Backend
        run: |
          for i in {1..10}; do
            if curl -f -s http://${{ steps.alb.outputs.alb_dns }}/api/v1/health; then
              echo "Backend health check passed"
              exit 0
            fi
            echo "Attempt $i failed, retrying..."
            sleep 10
          done
          echo "Backend health check failed"
          exit 1

      - name: Health check - Frontend
        run: |
          for i in {1..10}; do
            if curl -f -s http://${{ steps.alb.outputs.alb_dns }}/api/health; then
              echo "Frontend health check passed"
              exit 0
            fi
            echo "Attempt $i failed, retrying..."
            sleep 10
          done
          echo "Frontend health check failed"
          exit 1

  # Notification
  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    if: always()
    needs: [setup, verify-deployment]

    steps:
      - name: Deployment notification
        run: |
          if [ "${{ needs.verify-deployment.result }}" == "success" ]; then
            echo "Deployment to ${{ needs.setup.outputs.environment }} completed successfully"
          else
            echo "Deployment to ${{ needs.setup.outputs.environment }} failed"
            exit 1
          fi
